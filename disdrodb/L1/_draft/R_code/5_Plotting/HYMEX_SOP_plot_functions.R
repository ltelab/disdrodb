# HYMEX_SOP_plot_functions.R
# HYMEX_SOP_plot_functions.R
#
# Functions to support plotting of HYMEX SOP data.
#
# Author: Tim Raupach <tim.raupach@epfl.ch>

library(gmt)
library(ggplot2)
library(gstat)
library(gridExtra)
library(ncdf4)
source("library/2DVD_functions.R")
source("library/DSD_functions.R")
source("library/Parsivel_functions.R")
source("library/timeseries_functions.R")
source("library/timedate_utils.R")
source("library/pluvio_functions.R")
source("library/uncertainty_functions.R")
source("library/network_functions.R")
source("library/geo_functions.R")
source("third-party/lib_DSD.R")

# Set the colour pallette for all plots generated by this code.
ColorPalette="Set1"

SOPevents_2013 = function() {
  # Define events that occurred over the HyMEX campaign in 2013.
  events = NULL
  events = rbind(events, data.frame(start="2013-09-07 06:10", end="2013-09-08 00:10", type="convective", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-09-14 23:30", end="2013-09-15 04:10", type="convective", IOP="", stringsAsFactors=F)) # Bright band at times, but cell structure.
  events = rbind(events, data.frame(start="2013-09-28 17:40", end="2013-09-29 09:15", type="convective", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-10-04 15:25", end="2013-10-04 21:30", type="stratiform", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-10-12 15:15", end="2013-10-12 23:20", type="stratiform", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-10-20 02:20", end="2013-10-20 10:10", type="convective", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-10-20 14:00", end="2013-10-21 05:15", type="convective", IOP="", stringsAsFactors=F)) # Limited radar coverage.
  events = rbind(events, data.frame(start="2013-10-22 21:40", end="2013-10-23 13:20", type="stratiform", IOP="", stringsAsFactors=F)) # I have said "stratiform" but it has a very high peak!
  events = rbind(events, data.frame(start="2013-10-27 03:20", end="2013-10-27 09:30", type="convective", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-11-02 18:55", end="2013-11-02 23:35", type="stratiform", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-11-04 07:05", end="2013-11-04 15:10", type="stratiform", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-11-05 09:30", end="2013-11-05 17:20", type="stratiform", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2013-11-18 04:00", end="2013-11-18 14:05", type="stratiform", IOP="", stringsAsFactors=F))

  events$start = as.POSIXct(events$start, tz="UTC")
  events$end = as.POSIXct(events$end, tz="UTC")
  return(events)
}

SOPevents_2012 = function() {
  # Define events that occurred over the HyMEX campaign in 2012.
  events = NULL
  events = rbind(events, data.frame(start="2012-09-18 20:00", end="2012-09-18 22:20", type="convective", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-09-18 22:30", end="2012-09-19 02:40", type="stratiform", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-09-24 02:00", end="2012-09-24 05:30", type="convective", IOP="6", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-09-25 11:30", end="2012-09-25 15:50", type="convective", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-09-26 05:30", end="2012-09-26 10:30", type="convective", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-09-26 14:30", end="2012-09-26 20:15", type="", IOP="", stringsAsFactors=F)) # No radar available for this event.
  events = rbind(events, data.frame(start="2012-09-29 12:10", end="2012-09-29 15:50", type="stratiform", IOP="8", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-10-08 18:50", end="2012-10-08 23:10", type="", IOP="", stringsAsFactors=F)) # No radar available for this event.
  events = rbind(events, data.frame(start="2012-10-11 19:00", end="2012-10-11 21:05", type="convective", IOP="12a", stringsAsFactors=F)) # Limited radar coverage.
  events = rbind(events, data.frame(start="2012-10-21 18:00", end="2012-10-22 19:00", type="convective", IOP="15b", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-10-25 22:00", end="2012-10-26 14:00", type="stratiform", IOP="16a", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-10-26 14:00", end="2012-10-27 03:15", type="convective", IOP="16a,16c", stringsAsFactors=F)) # Appears convective then stratiform
  events = rbind(events, data.frame(start="2012-10-31 09:50", end="2012-10-31 17:45", type="stratiform", IOP="18", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-11-03 16:20", end="2012-11-04 19:00", type="", IOP="", stringsAsFactors=F)) # Limited radar data for this event.
  events = rbind(events, data.frame(start="2012-11-09 12:30", end="2012-11-10 18:00", type="stratiform", IOP="", stringsAsFactors=F))
  events = rbind(events, data.frame(start="2012-11-24 14:30", end="2012-11-25 01:00", type="convective", IOP="", stringsAsFactors=F)) # No radar data available. This event also missed by the 2DVD.
  events = rbind(events, data.frame(start="2012-11-26 04:00", end="2012-11-27 06:00", type="stratiform", IOP="", stringsAsFactors=F))

  events$start = as.POSIXct(events$start, tz="UTC")
  events$end = as.POSIXct(events$end, tz="UTC")
  return(events)
}

SOPevents_roof2008 = function() {
  # Define events that occurred over the roof 2008 campaign at EPFL LTE.
  events = NULL
  events = rbind(events, data.frame(start='2009-02-06 19:28:00', end='2009-02-07 22:37:00'))
  events = rbind(events, data.frame(start='2009-02-09 17:52:00', end='2009-02-10 21:34:00'))
  events = rbind(events, data.frame(start='2009-02-17 17:34:00', end='2009-02-18 00:27:00'))
  events = rbind(events, data.frame(start='2009-02-22 07:22:00', end='2009-02-22 08:57:00'))
  events = rbind(events, data.frame(start='2009-03-01 14:45:00', end='2009-03-02 18:20:00'))
  events = rbind(events, data.frame(start='2009-03-04 19:10:00', end='2009-03-06 23:30:00'))
  events = rbind(events, data.frame(start='2009-03-10 12:04:00', end='2009-03-11 08:40:00'))
  events = rbind(events, data.frame(start='2009-03-24 01:26:00', end='2009-03-24 23:32:00'))
  events = rbind(events, data.frame(start='2009-03-25 14:38:00', end='2009-03-26 05:37:00'))
  events = rbind(events, data.frame(start='2009-03-28 06:28:00', end='2009-03-29 06:22:00'))
  events = rbind(events, data.frame(start='2009-04-16 09:39:20', end='2009-04-16 12:40:20'))
  events = rbind(events, data.frame(start='2009-05-14 19:09:00', end='2009-05-16 00:42:00'))
  events = rbind(events, data.frame(start='2009-05-26 15:30:00', end='2009-05-26 22:36:00'))
  events = rbind(events, data.frame(start='2009-06-05 20:37:00', end='2009-06-07 00:00:00'))
  events = rbind(events, data.frame(start='2009-06-08 14:40:00', end='2009-06-09 03:15:00'))
  events = rbind(events, data.frame(start='2009-06-14 16:20:00', end='2009-06-15 05:31:00'))
  events = rbind(events, data.frame(start='2009-06-15 18:45:00', end='2009-06-15 19:37:00'))
  events = rbind(events, data.frame(start='2009-07-07 15:06:00', end='2009-07-07 19:50:00'))
  events = rbind(events, data.frame(start='2009-07-14 19:20:20', end='2009-07-15 06:03:20'))
  events = rbind(events, data.frame(start='2009-07-16 23:21:40', end='2009-07-17 07:35:00'))
  events = rbind(events, data.frame(start='2009-07-17 11:32:40', end='2009-07-17 19:00:00'))
  events = rbind(events, data.frame(start='2009-07-18 01:50:40', end='2009-07-18 08:46:00'))
  events = data.table(events)
  events = events[, start := as.POSIXct(start, tz="UTC")]
  events = events[, end := as.POSIXct(end, tz="UTC")]
  return(events)
}

stationsDefinition_2014 = function() {
  # Define Parsivel stations for HYMEX campaign in Ardeche in 2014.
  #
  # Returns:
  #  A data.frame containing station number, name, label (for plotting),
  #  latitude (lat), longitude (lon), altitude [m], x_metres, y_metres,
  #  projString,

  stations = NULL
  stations = rbind(stations, c(10, "Mirabel", "Mirabel", "44:36.416", "4:29.923", 496))
  stations = rbind(stations, c(11, "Lussas", "Lussas", "44:36.739", "4:28.238", 289))
  stations = rbind(stations, c(12, "St-Germain", "St-Germain", "44:33.305", "4:26.980", 204))
  stations = rbind(stations, c(13, "Lavilledieu", "Lavilledieu", "44:34.631", "4:27.195", 227))
  stations = rbind(stations, c(30, "Pradel Grainage", "Pradel Grainage", "44:34.740", "4:30.066", 271))
  stations = rbind(stations, c(31, "Les Blaches", "Les Blaches", "44:36.049", "4:28.859", 429))
  stations = rbind(stations, c(32, "Pradel 1", "Pradel", "44:34.973", "4:29.920", 278))
  stations = rbind(stations, c(33, "Pradel 2", "", "44:34.973",  "4:29.920", 278))

  stations = as.data.frame(stations, stringsAsFactors=F)
  stations$intTime = 30
  names(stations) = c("number", "name", "label", "lat", "lon", "altitude", "intTime")

  stations = geolocateStations(stations)
  return(stations)
}

stationsDefinition_2013 = function() {
  # Define Parsivel stations for HYMEX campaign in Ardeche in 2013.
  #
  # Returns:
  #  A data.frame containing station number, name, label (for plotting),
  #  latitude (lat), longitude (lon), altitude [m], x_metres, y_metres,
  #  projString,

  stations = NULL
  stations = rbind(stations, c(10, "Mirabel", "Mirabel", "44:36.416", "4:29.923", 496))
  stations = rbind(stations, c(11, "Lussas", "Lussas", "44:36.739", "4:28.238", 289))
  stations = rbind(stations, c(12, "St-Germain", "St-Germain", "44:33.305", "4:26.980", 204))
  stations = rbind(stations, c(13, "Lavilledieu", "Lavilledieu", "44:34.631", "4:27.195", 227))
  stations = rbind(stations, c(20, "Montbrun", "Montbrun", "44:36.845", "4:32.763", 602))
  stations = rbind(stations, c(30, "Pradel Grainage", "Pradel Grainage", "44:34.740", "4:30.066", 271))
  stations = rbind(stations, c(31, "Les Blaches", "Les Blaches", "44:36.049", "4:28.859", 429))
  stations = rbind(stations, c(32, "Pradel 1", "Pradel", "44:34.973", "4:29.920", 278))
  stations = rbind(stations, c(33, "Pradel 2", "", "44:34.973",  "4:29.920", 278))

  stations = as.data.frame(stations, stringsAsFactors=F)
  stations$intTime = 30
  names(stations) = c("number", "name", "label", "lat", "lon", "altitude", "intTime")

  stations = geolocateStations(stations)
  return(stations)
}

stationsDefinition_2012 = function() {
  # Define Parsivel stations for HYMEX campaign in Ardeche in 2012.
  #
  # Returns:
  #  A data.frame containing station number, name, label (for plotting),
  #  latitude (lat), longitude (lon), altitude [m], x_metres, y_metres,
  #  projString,

  stations = NULL
  stations = rbind(stations, c(10, "Mirabel", "Mirabel", "44:36.416", "4:29.923", 496))
  stations = rbind(stations, c(11, "Lussas", "Lussas", "44:36.739", "4:28.238", 289))
  stations = rbind(stations, c(13, "Lavilledieu", "Lavilledieu", "44:34.631", "4:27.195", 227))
  stations = rbind(stations, c(30, "Les Blaches", "Les Blaches", "44:36.049", "4:28.859", 429))
  stations = rbind(stations, c(31, "St-Germain", "St-Germain", "44:33.305", "4:26.980", 204))
  stations = rbind(stations, c(32, "Pradel 1", "Pradel", "44:34.973", "4:29.920", 278))
  stations = rbind(stations, c(33, "Pradel 2", "", "44:34.973",  "4:29.920", 278))
  # stations = rbind(stations, c(50, "2DVD Le Pradel", "", "",  ""))
  stations = as.data.frame(stations, stringsAsFactors=F)
  names(stations) = c("number", "name", "label", "lat", "lon", "altitude")

  stations = geolocateStations(stations)
  return(stations)
}

pluvioStationsDefinition = function(file=paste("~/Switch/phd/pluvio_info/",
                                               "HYMEX_stationLocations.nc",
                                               sep="")) {
  # Define pluvio stations for HPicoNet data for Ardeche, France.
  #
  # Returns:
  #  A data.frame containing station number, name, label (for plotting),
  #  latitude (lat), and longitude (lon), x_metres, y_metres, projString

  nc = nc_open(file)
  stationNames = gsub(" *", "", ncvar_get(nc, "station_name"))
  x = ncvar_get(nc, "x_liie")
  y = ncvar_get(nc, "y_liie")
  z = ncvar_get(nc, "z")

  stations = data.frame(number=seq(1, length(stationNames)), name=stationNames,
                        x=x, y=y, altitude=z)

  coordinates(stations) = ~x+y
  proj4string(stations) = CRS(paste("+proj=lcc +lat_1=46.8 +lat_0=46.8",
                                    "+lon_0=0 +k_0=0.99987742 +x_0=600000",
                                    "+y_0=2200000 +a=6378249.2 +b=6356515",
                                    "+towgs84=-168,-60,320,0,0,0,0 +pm=paris",
                                    "+units=m +no_defs"))

  # Convert to lat/long.
  stations = spTransform(stations,
                         CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))

  # Extract lat/long and make data.frame.
  # NOTE: lat and long are transposed in current version of NC file.
  print("WARNING: Lat and long are transposed, manually fixed.")
  stations$lat = coordinates(stations)[,2]
  stations$lon = coordinates(stations)[,1]
  stations$label = stations$name
  stations = data.frame(stations)

  # Remove x and y.
  stations$x = NULL
  stations$y = NULL

  # Project to metres.
  projString = paste("+proj=lcc +lat_1=44.10000000000001",
                     "+lat_0=44.10000000000001 +lon_0=0",
                     "+k_0=0.999877499 +x_0=600000 +y_0=3200000",
                     "+a=6378249.2 +b=6356515",
                     "+towgs84=-168,-60,320,0,0,0,0 +pm=paris",
                     "+units=m +no_defs")
  projCRS = CRS(projString)
  # See http://spatialreference.org/ref/epsg/27573/ for projection details.

  coords = data.frame(lat=stations$lat, lon=stations$lon)
  coordinates(coords) = ~lon+lat
  proj4string(coords) = CRS("+proj=longlat +datum=WGS84")

  metre_coords = spTransform(coords, projCRS)

  stations$x_metres = coordinates(metre_coords)[,1]
  stations$y_metres = coordinates(metre_coords)[,2]
  stations$metres_proj4 = projString

  ## Remove Mirabel Pradel Vignes because it was not reliable.
  stations = data.table(stations, stringsAsFactors=FALSE)
  stations = stations[name != "Mirabel-Pradel-Vignes"]

  return(stations)
}

plotStationLocations = function(stations=stationsDefinition(), textSize=14) {
  # Plot station relative locations.
  #
  # Args:
  #   stations: stations definition (default: from stationsDefinition()).
  #
  # Returns: plot.

  plot = ggplot(stations, aes(x=lon, y=lat)) +
    geom_point(shape=4, size=3) +
    geom_text(aes(label=label), vjust=1.5, size=7) +
    theme_bw(textSize) +
    labs(title=paste("Geographic distribution of disdrometer stations\n",
                     "HYMEX SOP 2012"),
         x="Longitude",
         y="Latitude") +
    scale_x_continuous(limits=c(min(stations$lon) - 0.01,
                                max(stations$lon) + 0.01)) +
    scale_y_continuous(limits=c(min(stations$lat) - 0.01,
                                max(stations$lat) + 0.01))

  return(plot)
}

plotDSDdistributions = function(parsivelRainySpectra,
                                cols=seq(4,35),
                                outDir=paste("~/Dropbox/phd/plots/",
                                             "HYMEX_SOP1/Mean DSDs/", sep="")) {
  # Plot a box plot per class, showing the distributions of drop counts
  # by station.
  #
  # Args:
  #   parsivelRainySpectra: Spectra to plot.
  #   cols: Columns for the classes to plot.
  #   outDir: Output directory.
  #
  # Returns: void.

  for(col in cols) {
    name = names(parsivelRainySpectra)[col]
    data = data.frame(parsivelRainySpectra$station,
                      parsivelRainySpectra[,col])
    names(data) = c("station", name)

    if(!(all(data[[name]] == 0))) {
      plot = ggplot(data, aes_string(x="station",y=name)) +
        geom_boxplot(aes(group=station, colour=station)) +
        theme_bw() +
        labs(title=paste("Distribution of drop counts across SOP1:",
                        "Class", col-min(cols)+1),
            x="Station",
            y="Drop count [log scale]") +
        scale_y_continuous(trans="log")

      ggsave(plot=plot, filename=paste(outDir,
                                       "/count_distribution_by_station_class",
                                       col-min(cols)+1, ".png", sep=""))
    }
  }
}

compareAverageToMeanDSDs = function(data,
                                    start=min(data$POSIXtime),
                                    end=max(data$POSIXtime),
                                    title="",
                                    xlimits=c(0,4),
                                    overlayClasses=F,
                                    textSize=16,
                                    cols=seq(6, 37),
                                    ylimits=range(data[,cols]),
                                    RThreshold=0.1,
                                    ...) {
  # Plot the mean DSD per parsivel station, for rainy events. This means
  # timesteps for which there was no rain recorded are not counted.
  #
  # Args:
  #   data: the DSD spectra.
  #   start, end: Consider data between these two times (>= start, <= end).
  #               POSIXct UTC dates. (Default: all data).
  #   startDate: start date for plot title.
  #   endDate: end date for plot title.
  #   xlimits: limits for x axis (default: c(0,4)).
  #   overlayClasses: Overlay class widths?
  #   cols: Columns of the DSD in data.
  #   RThreshold: The minimum rainrate to consider. (Default: 0.1).
  #   ...: Extra arguments to meanDSDs().
  #
  # Returns: plot ready to display.

  # Subset the data to selected times and for which rain rate is greater than
  # the threshold.
  dataSubset = data[which(data$POSIXtime >= start &
                          data$POSIXtime <= end &
                          data$R >= RThreshold),]

  # Find the mean DSDs and the global mean.
  meanDSDs = meanDSDs(dataSubset, cols, ...)

  # Get diameter class centres.
  classes = get.classD()
  centres = rowMeans(classes)
  dataCentres = unique(meanDSDs$diameterClassCentre)
  dataCentres = dataCentres[order(dataCentres)]
  stopifnot(max(abs(dataCentres - centres)) < 10e-10)

  # Get the global mean DSD.
  globalMean = colMeans(dataSubset[,cols], na.rm=T)
  globalMean = data.frame(diameterClassCentre=dataCentres, station="Global",
                          number=globalMean)

  line = geom_line(data=meanDSDs, size=0.75, aes(group=station), colour="grey")
  globalLine = geom_line(data=globalMean, size=1.5, colour="black")

  # Plot it all.
  plot =
    ggplot(meanDSDs, aes(x=diameterClassCentre, y=number, group=station)) +
    line + globalLine +
    labs(title=title,
         x="Drop diameter [mm]",
         y=expression(paste(N(D), " [", mm^-3, " ", m^-1, "]"))) +
    theme_bw(textSize) +
    scale_x_continuous(limits=xlimits) +
    scale_y_continuous(limits=ylimits)

  return(plot)
}

plotMeanDSDPerStation = function(meanDSDs, startDate, endDate,
                                 stationNames=unique(levels(meanDSDs$station)),
                                 xlimits=c(0,4), bw=F,
                                 timestring = paste(startDate, "to", endDate),
                                 overlayClasses=F, textSize=16) {
  # Plot the mean DSD per parsivel station, for rainy events. This means
  # timesteps for which there was no rain recorded are not counted.
  #
  # Args:
  #   meanDSDs: the mean DSDs to plot (data.frame containing )
  #   startDate: start date for plot title.
  #   endDate: end date for plot title.
  #   stationNames: station names to plot (default: all stations).
  #   xlimits: limits for x axis (default: c(0,4)).
  #   bw: plot in black and white, using line type to distinguish
  #       stations? (Default: False).
  #   timesting: time period to write in title (default: startDate
  #              "to" endDate).
  #   overlayClasses: Overlay class widths?
  #
  # Returns: plot ready to display.

  # Only plot requested stations.
  plotData = meanDSDs[which(as.character(meanDSDs$station) %in% stationNames), ]

  # Define whether to use black and white (different lines per station)
  # or colour (different colour per station, with solid lines.)
  if(bw) {
    line = geom_line(data=plotData, size=1, aes(linetype=station))
    scale = scale_linetype(name="Station")
  } else {
    line = geom_line(data=plotData, size=1, aes(colour=station))
    scale = scale_colour_brewer(type="all", palette=ColorPalette, name="Station")
  }

  bar_plot = NULL
  if(overlayClasses) {
    classes = get.classD()
    centres = rowMeans(classes)
    dataCentres = unique(plotData$diameterClassCentre)
    dataCentres = dataCentres[order(dataCentres)]
    stopifnot(max(abs(dataCentres - centres)) < 10e-10)
    widths = apply(classes, 1, diff)
    bars = data.frame(diameterClassCentre=dataCentres, classWidth=widths)

    plotData = merge(plotData, bars, by="diameterClassCentre", all=TRUE)
    plotData$barHeight = max(plotData$number)
    bar_plot = geom_bar(aes(x=diameterClassCentre, y=barHeight, width=classWidth),
                        stat="identity", position="identity", fill=NA,
                        color="grey")
  }

  # Plot it all.
  plot = ggplot(plotData, aes(x=diameterClassCentre, y=number, group=station)) +
    bar_plot + line + scale +
    labs(title = paste("Station average DSD for rain events\n",
                       "HYMEX SOP", timestring),
         x="Drop diameter [mm]",
         y=expression(paste(N(D), " [", mm^-3, " ", m^-1, "]"))) +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.position="right", #"c(0.9, 0.8)",
          legend.key=element_rect(colour="white")) +
    scale_x_continuous(limits=xlimits)

  return(plot)
}

plotAccumulatedRainfall = function(statsPerStation,
                                   start, end,
                                   stationNames=
                                     unique(levels(statsPerStation$station)),
                                   textSize=14,
                                   bw = F) {
  # Plot accumulated rainfall.
  #
  # Args:
  #   statsPerStation: statistics per station, from readDailyStatsPerStation().
  #   start, end: start, end dates to plot (POSIXct, UTC).
  #   stationNames: station names to plot (default: all stations).
  #   bw: plot in black and white and use line types as feature?
  #       (Default: False).
  #
  # Returns: the plot.

  startDate = strftime(start, format="%Y-%m-%d %H:%M:%S", tz="UTC")
  endDate = strftime(end, format="%Y-%m-%d %H:%M:%S", tz="UTC")

  idx = which(statsPerStation$POSIXtime >= start &
                statsPerStation$POSIXtime <= end &
                as.character(statsPerStation$station) %in% stationNames)
  plotData = statsPerStation[idx,]

  # Define whether to use black and white (different lines per station)
  # or colour (different colour per station, with solid lines.)
  if(bw) {
    line = geom_line(size=1, aes(linetype=station))
    scale = scale_linetype(name="Station")
  } else {
    line = geom_line(size=1, aes(colour=station))
    scale = scale_colour_brewer(type="all", palette=ColorPalette, name="Station")
  }

  plotData$amount[which(is.na(plotData$amount))] = 0
  accums = ddply(plotData, .(station), summarise,
                 POSIXtime=POSIXtime,
                 accumulatedRainAmount=cumsum(amount))

  plot = ggplot(accums, aes(x=POSIXtime,
                              y=accumulatedRainAmount,
                              group=station)) +
    line + scale +
    labs(title=paste("Accumulated daily rain amount\n",
                     "HYMEX SOP,",
                     startDate, "to", endDate),
         x="Date",
         y="Accumulated rain amount [mm]") +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          #legend.position=c(0.1, 0.8),
          legend.key=element_rect(colour="white"))

  return(plot)
}

plotStationDiffsByTime = function(statsPerStation,
                                  title="",
                                  variable="R", unit="mm/h",
                                  stationNames=c("Pradel 1", "Pradel 2"),
                                  textSize=14) {
  # Plot station differences by time. NAs are not removed.
  #
  # Args:
  #   statsPerStation: statistics per station.
  #   title: Title to use (default: none).
  #   variable: The variable to find differences for.
  #   stationNames: station names to plot (default: Pradels 1 and 2).
  #   textSize: Text size for the plot.
  #
  # Returns: the plot.

  # Find differences
  stat1 = statsPerStation[which(statsPerStation$station == stationNames[1]),]
  stat2 = statsPerStation[which(statsPerStation$station == stationNames[2]),]

  # Check times are the same.
  stopifnot(stat1$POSIXtime == stat2$POSIXtime)

  diffs = stat1[[variable]] - stat2[[variable]]
  toPlot=data.frame(time=stat1$POSIXtime, diff=diffs)

  plot =
    ggplot(toPlot, aes(x=time, y=diff)) +
    geom_linerange(aes(x=time, ymin=0, ymax=diff)) +
    labs(title=title,
         x="Date",
         y=paste("Difference in", variable, paste("[", unit, "]", sep=""))) +
    theme_bw(textSize)

  return(plot)
}

plotMeanRateByTimestep = function(meanAcrossStations, textSize=14) {
  # Plot mean rainfall across stations per timestep.
  #
  # Args:
  #   meanAcrossStations = output of meanRainRatePerTimestep().
  #
  # Returns: the plot.

  plot = ggplot(meanAcrossStations, aes(x=POSIXtime, y=R_mean)) +
    geom_line(size=1, aes()) +
    labs(title=paste("Mean rain rate over network at 30 s time steps.\n",
                     "HYMEX SOP,", startDate, "to", endDate),
         x="Date",
         y=expression(paste("Mean rain rate ", bar(R),
                            " [mm ", h^{-1}, "]", sep=""))) +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.position=c(0.1, 0.8),
          legend.key=element_rect(colour="white"))

  return(plot)
}

plotNtVariance = function(spreadStats, startDate, endDate, textSize=14) {
  # Plot CV of drop concentration against mean of drop concentration.
  #
  # Args:
  #   spreadStats = output of calculateSpreadStats().
  #
  # Returns: the plot.

  plot = ggplot(spreadStats, aes(x=Nt_mean, y=Nt_cv)) +
    geom_point() +
    labs(title=paste("Coefficient of variation (CV) vs. mean of",
                     "drop concentration N_t\n",
                     "HYMEX SOP,", startDate, "to", endDate),
         x=expression(paste("Drop concentration ",
                            bar(N[t]), " [", m^{-3}, "]", sep="")),
         y=expression(paste("CV drop concentration", CV[N[t]], sep=""))) +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.position=c(0.1, 0.8),
          legend.key=element_rect(colour="white"))

  return(plot)
}

plotRainrateVariance = function(spreadStats, startDate, endDate, textSize=14) {
  # Plot CV of rain rate against mean of rain rate.
  #
  # Args:
  #   spreadStats = output of calculateSpreadStats().
  #
  # Returns: the plot.

  plot = ggplot(spreadStats, aes(x=R_mean, y=R_cv)) +
    geom_point() +
    labs(title=paste("Coefficient of variation (CV) vs. mean of rainrate\n",
                     "HYMEX SOP,", startDate, "to", endDate),
         x=expression(paste("Mean rainrate ",
                            bar(R), " [mm ", h^{-1}, "]", sep="")),
         y=expression(paste("CV rainrate ", CV[R], sep=""))) +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.position=c(0.1, 0.8),
          legend.key=element_rect(colour="white"))

  return(plot)
}

plotD0Variance = function(spreadStats, startDate, endDate, textSize=14) {
  # Plot CV of median volume diameter vs mean median volume diameter.
  #
  # Args:
  #   spreadStats = output of calculateSpreadStats().
  #
  # Returns: the plot.

  plot = ggplot(spreadStats, aes(x=D0_mean, y=D0_cv)) +
    geom_point() +
    labs(title=paste("Coefficient of variation (CV) vs. mean of median",
                     "volume drop diameter\n",
                     "HYMEX SOP,", startDate, "to", endDate),
         x=expression(paste("Mean median volume diameter ",
                            bar(D[0]), " [mm]", sep="")),
         y=expression(paste("CV median volume diameter ", CV[D[0]], sep=""))) +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.position=c(0.1, 0.8),
          legend.key=element_rect(colour="white"))

  return(plot)
}

plotDropConcentrationComparisonTS = function(data, start, end, textSize=14) {
  # Plot comparison of drop concentrations over time.
  #
  # Args:
  #  data = data.frame containing timestamp, station, Nt.
  #  start = start date (POSIXct).
  #  end = end date (POSIXct).
  #
  # Returns: the plot.

  timestring = paste(strftime(as.Date(start), "%Y-%m-%d", tz="UTC"), "to",
                     strftime(as.Date(end), "%Y-%m-%d", tz="UTC"))
  plot = ggplot(data=data, aes(x=ts, y=Nt, group=station)) +
    geom_line(size=1, aes(color=station)) +
    scale_colour_brewer(type="all", palette=ColorPalette, name="Station") +
    scale_y_sqrt() +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.position=c(0.9, 0.8),
          legend.key=element_rect(colour="white")) +
    labs(title = paste("Drop concentration comparison [sqrt scale]\n",
                       "HYMEX SOP", timestring),
         x="Timestep",
         y=expression(paste(N(t), " [", m^-3, "]")))

  return(plot)
}

compareStations = function(data, otherData,
                           station, otherStation,
                           stationType="Pluvio",
                           otherStationType="Parsivel",
                           timePeriod="5 min",
                           roundDP=NA,
                           removeZeroPairs=T,
                           dataRange=numeric(0),
                           excludeSolid=T,
                           solidTSToExclude=0,
                           statName="rain amount [mm]",
                           convertFun=function(x) {return(x)},
                           title=T,
                           variable="amount",
                           ...) {
  # Compare rain amounts collected by an instrument to another station.
  #
  # Args:
  #   data: the first dataset containing station, timestamp, amount.
  #   otherData: the second dataset containing station, timestamp, amount
  #              at the same temporal resolution as the first dataset.
  #   station: which station (name) in the first dataset to compare?
  #   otherStation: which station in the second dataset to to compare?
  #   timePeriod: Time resolution for plot title (default: "5 min").
  #   roundDP: Number of decimal places to round amounts to (NA for no
  #            rounding) (default: NA).
  #   removeZeroPairs: Remove pairs of zeros? (Default: T).
  #   dataRange: Range of amounts for data (ie only for one set) (default: all).
  #   excludeSolid: Exclude all solid precip? (default: T)
  #   solidTSToExclude: Number of (extra) timesteps after solid precip is
  #                     detected to exclude? (Default: 0)
  #   statName: The statistic name to include in the title and axes
  #             (default: "amount [mm]")
  #   convertFun: Optional function to convert amount. (Default:
  #               no conversion).
  #   title: Include the title?
  #   variable: Which variable to compare? (Default: amount).
  #   ... : Extra arguments to comparisonStatsAndPlot
  #
  # Returns:
  #   A data.frame containing rmse, bias, correlation (corr) and a scatterplot.

  # Sort out labels and names.
  stationLabel = paste(station, stationType)
  otherStationLabel = paste(otherStation, otherStationType)
  stationName = stationLabel
  otherStationName = otherStationLabel

  if(stationType == station) {
    stationLabel = station
    stationName = station
  }
  if(otherStationType == otherStation) {
    otherStationLabel = otherStation
    otherStationName = station
  }

  # Station names in data.frames must be different.
  stopifnot(stationName != otherStationName)

  data = data[which(data$station == station),]
  data$station = stationName

  other = otherData[which(otherData$station == otherStation),]
  other$station = otherStationName

  data[[variable]] = convertFun(data[[variable]])
  other[[variable]] = convertFun(other[[variable]])

  # Remove rows that don't match between the two datasets.
  idx = which(!(other$POSIXtime %in% data$POSIXtime))
  if(length(idx) > 0) {
    print(paste("WARNING:", length(idx), "first dataset timestamps missing."))
    other = other[-idx,]
  }
  idx = which(!(data$POSIXtime %in% other$POSIXtime))
  if(length(idx) > 0) {
    print(paste("WARNING:", length(idx), "second dataset timestamps missing."))
    data = data[-idx,]
  }

  rangeText = ""

  # If a range is specified, subset to pairs in which data is within range.
  if(length(dataRange) != 0) {
    min = dataRange[1]
    max = dataRange[2]
    rangeText = paste("\nValue range: [", min, ", ", max, "]", sep="")
    idx = which(data[[variable]] >= min & data[[variable]] < max)

    data = data[idx,]
    other = other[idx,]
  }

  # Remove rows where there were "suspicous" parsivel readings
  idxData = numeric(0)
  idxOther = numeric(0)
  if("containedSusp" %in% names(data)) {
    idxData = which(data$containedSusp == T)
  }
  if("solidPrecipProp" %in% names(other)) {
    idxOther = which(other$containedSusp == T)
  }
  idx = union(idxData, idxOther)
  if(length(idx) > 0) {
    data = data[-idx,]
    other = other[-idx,]
  }

  # Always exclude those timesteps where solid precip is NA - these
  # mean missing data.
  idxData = numeric(0)
  idxOther = numeric(0)

  if("solidPrecipProp" %in% names(data)) {
    idxData = which(is.na(data$solidPrecipProp))
  }
  if("solidPrecipProp" %in% names(other)) {
    idxOther = which(is.na(other$solidPrecipProp))
  }

  idx = union(idxData, idxOther)
  if(length(idx) > 0) {
    data = data[-idx,]
    other = other[-idx,]
  }

  # Exclude solid precipitation?
  if(excludeSolid) {
    idxData = numeric(0)
    idxOther = numeric(0)

    if("solidPrecipProp" %in% names(data)) {
      idxData = which(data$solidPrecipProp > 0)
    }
    if("solidPrecipProp" %in% names(other)) {
      idxOther = which(other$solidPrecipProp > 0)
    }

    idx = union(idxData, idxOther)

    # Also exclude solidTSToExclude timesteps after each solid timestep.
    if(solidTSToExclude > 0) {
      extraExcl = NULL
      for(ts in idx) {
        extraExclSeq = seq(ts+1, ts+solidTSToExclude-1)
        extraExcl = c(extraExcl, extraExclSeq)
      }
      idx = union(idx, extraExcl)
    }

    if(length(idx) > 0) {
      data = data[-idx,]
      other = other[-idx,]
    }
  }

  # Round stats?
  if(!is.na(roundDP)) {
    other[[variable]] = round(other[[variable]], roundDP)
    data[[variable]] = round(data[[variable]], roundDP)
  }

  # Remove columns other than timesetamp, station and amount.
  data = data.frame(POSIXtime=data$POSIXtime,
                    station=data$station,
                    variable=data[[variable]])
  other = data.frame(POSIXtime=other$POSIXtime,
                     station=other$station,
                     variable=other[[variable]])
  extraTitle = rangeText

  # Remove pairs of zeros? Done by next function so just reflect in
  # title..
  if(removeZeroPairs) {
    extraTitle = paste(extraTitle, "\n[Zero-zero pairs removed]", sep="")
  }

  # Number of timesteps in data and other should be exactly the same.
  stopifnot(data$POSIXtime == other$POSIXtime)
  stopifnot(length(data$POSIXtime) == length(other$POSIXtime))

  # Join together by rows.
  names(data) = c("POSIXtime", "station", variable)
  names(other) = c("POSIXtime", "station", variable)
  stats = rbind(data, other)

  results = comparisonStatsAndPlot(stats,
                                   statName=variable,
                                   stationOneName=stationName,
                                   stationTwoName=otherStationName,
                                   statLongName=paste(timePeriod,
                                                      statName, "at",
                                                      otherStation,
                                                      extraTitle),
                                   axisOneLabel=paste(stationLabel,
                                                      statName),
                                   axisTwoLabel=paste(otherStationLabel,
                                                      statName),
                                   removeZeroPairs=removeZeroPairs,
                                   title=title,
                                   ...)

  print(paste("r =", results$corr))
  print(paste("RMSE =", results$rmse))
  print(paste("Bias =", results$bias))
  print(paste("Relative bias =", results$relBias))

  return(results)
}

compareTwoEvents = function(data,
                            startDateOne, startDateTwo,
                            timesteps,
                            eventOneDesc,
                            eventTwoDesc,
                            timescale,
                            variables=c("R", "Nt", "Dm", "Zh"),
                            units=c("mm~h^{-1}", "m^{-3}", "mm", "dBZ"),
                            displayNames=c("rain rate",
                                           "total drop concentration",
                                           "mass-weighted drop diameter",
                                           "horizontal radar reflectivity"),
                            scales=c("sqrt", "sqrt", "continuous",
                                     "continuous"),
                            title="",
                            textSize=14,
                            legend=rep(T, length(variables)),
                            xlab=rep(T, length(variables))) {
  # Compute and return plots to show a comparison between two
  # different events.
  #
  # Args:
  #   data: The statistics data including both events' timeseries.
  #   startDateOne: The start timestamp of the first event (POSIXct).
  #   startDateTwo: The start timestamp of the second event (POSIXct).
  #   timesteps: The number of timesteps to compare.
  #   eventOneDesc: Description of event one.
  #   eventTwoDesc: Description of event two.
  #   timescale: Timescale to display (eg "30 s", "one minute").
  #   variables: Variables to plot.
  #   units: Units for each variable.
  #   displayNames: display name for each variable.
  #   scales: Scale to use for each variable.
  #   title: Title to display, or F for no title. Default, a title will be
  #          made automatically.
  #   legend: Display a legend? (Default: TRUE for all).
  #   xlab: Display the x label? (Default: TRUE for all).
  #
  # Returns:
  #   A data.frame containing plots.

  stopifnot(length(variables) == length(units) &
            length(units) == length(displayNames))

  # Find all unique times.
  ts = unique(data$POSIXtime)[order(unique(data$POSIXtime))]

  # Start indexes.
  idxOne = which(data$POSIXtime >= startDateOne &
                   data$POSIXtime < ts[which(ts >= startDateOne)[1] + timesteps])
  idxTwo = which(data$POSIXtime >= startDateTwo &
                   data$POSIXtime < ts[which(ts >= startDateTwo)[1] + timesteps])
  # Subset data.
  subsetOne = data[idxOne,]
  subsetTwo = data[idxTwo,]

  plots = NULL

  # Plot comparison of each variable.
  for(i in seq(1, length(variables))) {
    variable = variables[i]
    unit = units[i]
    displayName = displayNames[i]
    scale = scales[i]
    plot = compareVariableRanges(subsetOne, subsetTwo, variable,
                                 eventOneDesc, eventTwoDesc,
                                 displayName=displayName,
                                 unit=unit,
                                 scale=scale,
                                 timescale=timescale,
                                 title=title,
                                 textSize=textSize,
                                 legend=legend[i],
                                 xlab=xlab[i])
    plots = c(plots, list(plot))
  }

  names(plots) = variables
  return(plots)
}

rangesForVariable = function(data, variable) {
  # Return the range of a variable per timestep across stations.
  #
  # Args:
  #   data: Data to find ranges for, must contain station, POSIXtime,
  #         variable.
  #   variable: The name of the variable to find ranges for.
  #
  # Returns:
  #   A data.frame containing POSIXtime, min, max.

  d = data.frame(timestamp=data$POSIXtime,
                 station=data$station,
                 val=data[[variable]])

  # Remove solid precip and filtered out values.
  d$val[which(data$precipCode == 1)] = NA
  d$val[which(data$precipCode == -2)] = NA

  res = suppressWarnings(
    ddply(d, .(timestamp), summarise,
        min=min(val, na.rm=T), max=max(val, na.rm=T)))

  res$min[which(is.infinite(res$min))] = NA
  res$max[which(is.infinite(res$max))] = NA

  return(res)
}

compareVariableRanges = function(setOne,
                                 setTwo,
                                 variable,
                                 setOneDesc,
                                 setTwoDesc,
                                 unit,
                                 displayName,
                                 timescale,
                                 title="",
                                 scale="continuous",
                                 textSize=14,
                                 legend=TRUE,
                                 xlab=TRUE,
                                 formatFunc=function(x) {
                                   format(x, width=4, justify="left")
                                 }) {
  # Create a plot that compares the ranges or means of two variables.
  #
  # Args:
  #   setOne: Data set one to compare.
  #   setTwo: Data set two to compare.
  #   variable: The name of the variable to compare.
  #   setOneDesc: Description of first set.
  #   setTwoDesc: Description of second set.
  #   unit: The variable's unit (for display).
  #   displayName: The display name of the variable.
  #   timescale: Timescale to display (eg "30 s", "one minute").
  #   title: Plot title (if blank, automatically generated).
  #   scale: Either log, sqrt, or NA. Sets y axis scale.
  #   legend: Display a scale legend? (Default: TRUE).
  #   formatFunc: A function to format y scale axis labels (default: width 3
  #               right justified).
  #
  # Returns:
  #   A ggplot2 object.

  stopifnot(length(setOne[[variable]]) == length(setTwo[[variable]]))
  stopifnot(setOneDesc != setTwoDesc)

  rangesOne = rangesForVariable(setOne, variable)
  rangesTwo = rangesForVariable(setTwo, variable)

  if(title=="") {
    title = paste("Comparison of two events by",
                  timescale, displayName)
  }

  if(title == F) {
    title = NULL
  }

  names(rangesOne) = c("ts", "min", "max")
  names(rangesTwo) = c("ts", "min", "max")

  rangesOne$ts = seq(1, length(rangesOne$min), by=1)
  rangesTwo$ts = seq(1, length(rangesTwo$min), by=1)

  ranges = rbind(data.frame(rangesOne, set=setOneDesc),
                 data.frame(rangesTwo, set=setTwoDesc))

  cols = c("red", "blue")

  scale_geom = scale_y_continuous()
  if(scale == "log") {
    scale_geom = scale_y_log10(labels=formatFunc)
  }
  if(scale == "sqrt") {
    scale_geom = scale_y_sqrt(labels=formatFunc)
  } else {
    scale_geom = scale_y_continuous(labels=formatFunc)
  }

  legendPos="top"
  if(!legend) {
    legendPos="none"
  }

  plot =
    ggplot(data=ranges) +
    geom_ribbon(data=ranges, aes(x=ts, ymin=min, ymax=max, group=set,
                                 colour=set, fill=set), alpha=0.5) +
    scale_geom +
    scale_fill_discrete(h=c(230, 0), l=c(70, 70), c=c(100, 100), name="") +
    scale_colour_discrete(h=c(230, 0), l=c(40, 40), c=c(100, 100), name="") +
    theme_bw(textSize) +
    theme(legend.position=legendPos) +
    labs(title=title,
         y=parse(text=paste(variable,
                            paste("group('[',", unit, ",']')",
                                  sep=""), sep="~")))

  if(xlab) {
    plot = plot + labs(x = paste("Time step (", timescale, ")", sep=""))
  } else {
    plot = plot + labs(x=NULL)
  }

  return(plot)
}

mkOutputDir = function(dirname, outDir=plotOutDir) {
  # Create a directory if it doesn't exist.
  #
  # Args:
  #  dirname: Subdirectory name.
  #  outDir: Parent directory.
  #
  # Returns: void.

  if(nchar(outDir) > 0) {
    fullname = paste(outDir, dirname, sep="/")
  } else {
    fullname = dirname
  }
  if(!file.exists(fullname, recursive=TRUE)) {
    dir.create(fullname, recursive=TRUE)
  }
}

savePlot = function(name, outDir=plotOutDir, plot=NA,
                    width=10, #par("din")[1],
                    height=6) { #par("din")[2]) {
  # Save a plot in an output directory.
  #
  # Args:
  #   name: Filename to save plot to.
  #   outDir: Directory to save in.
  #
  # Returns:
  #   void.

  if(length(plot) != 0) {
    ggsave(plot=plot, paste(outDir, name, sep="/"), width=width, height=height)
  } else {
    ggsave(paste(outDir, name, sep="/"), width=width, height=height)
  }
}

saveEventAnalysisPlots = function(event, prefix, subDir="",
                                  outDir=plotOutDir,
                                  variogramVars = c("R", "amount", "LWC",
                                                    "Nt", "D0"),
                                  variogramsOnly=F) {
  # Plot output from analyseNetworkEvent().
  #
  # Args:
  #   event: Output from analyseNetworkEvent().
  #   prefix: Output filename prefix.
  #   subDir: Output subdir (created if doesn't exist).
  #   outDir: Output base directory (must exist, defaults to plotOutDir).
  #   variogramVars: Variables for which to expect and save variogram plots.
  #   variogramsOnly: Only output variograms? (Default: F).
  #
  # Returns:
  #   void.

  dir = paste(plotOutDir, subDir, sep="/")
  if(!file.exists(dir, recursive=T)) {
    dir.create(dir, recursive=T)
  }

  if(!variogramsOnly) {
    # Rain rate by time
    print(event$rainratePlot)
    savePlot(paste(prefix, "rainrate.png", sep=""), outDir=dir)

    # Mean DSD
    print(event$meanDSDPlot)
    savePlot(paste(prefix, "meanDSD.png", sep=""), outDir=dir)
  }

  # Variograms
  for(var in variogramVars) {
    print(event$variograms[[var]]$plot)
    savePlot(paste(prefix, "variogram-", var, ".png", sep=""), outDir=dir)
  }
}

analyseAndPlotEvent = function(data, start, end, eventName) {
  # Analyse a specific event, and plot results.
  # Variograms will be generated with fits using the zero-distance nugget
  # and without.
  #
  # Args:
  #   data: Parsivel data and stats.
  #   start: Start time (POSIXct).
  #   end: End time (POSIXct).
  #   eventName: Name for event to be used in filenames. No spaces.
  #
  # Returns:
  #   void.

  # Analyse event without using zero-dist nuggets.
  event = analyseNetworkEvent(stats=data, start=start, end=end)

  # Analyse event using zero-dist nuggets.
  event_nugget = analyseNetworkEvent(stats=data, start=start, end=end,
                                      useZeroDistNugget=T)

  # Save plots.
  saveEventAnalysisPlots(event, prefix=paste(eventName, "-", sep=""),
                         subDir=paste("events", eventName, sep="/"))
  saveEventAnalysisPlots(event_nugget,
                         prefix=paste(eventName, "-real-nugget-", sep=""),
                         subDir=paste("events", eventName, sep="/"),
                         variogramsOnly=T)

  return(list(nonugget=event,
              nugget=event_nugget))
}

precipCodeDesc = function() {
  pCodes = data.frame(code = seq(-3,1),
                      desc = c("Manually removed.",
                               "Parsivel filtered",
                               "Dry",
                               "Liquid precip",
                               "Solid precip"),
                      stringsAsFactors=F)
  return(pCodes)
}

plotStatPerStation = function(stats, stat,
                              statName,
                              statUnits,
                              start, end,
                              stationNames=unique(levels(stats$station)),
                              bw = F,
                              plotTitle=T,
                              includePrecipCode=F,
                              precipCodes = precipCodeDesc(),
                              textSize=10,
                              bandStations = numeric(0),
                              bandName="",
                              bandColour="orange",
                              bandAlpha=0.7) {
  # Plot any stat per station on the same plot.
  #
  # Args:
  #   statsPerStation = statistics per station.
  #   stat: the name of the statistic to plot.
  #   statName: The name of the statisting for the title.
  #   start: start time (POSIXct).
  #   end: end time (POSIXct).
  #   stationNames: station names to plot (default: all stations).
  #   bw: plot in black and white and use line types as feature?
  #       (Default: False).
  #   textSize: Text size to use?
  #   bandStations: Which stations to put into a "band" showing their
  #                 min and max values?
  #   bandName: The name for the banded stations.
  #   bandColour: Colour of the grouped stations band.
  #   bandAlpha: Alpha value for the band.
  #
  # Returns:
  #   A ggplot2 object ready to display or save.

  # Subset by date.
  idx = which(stats$POSIXtime >= start & stats$POSIXtime <= end)
  stats = stats[idx,]

  # Subset for only requested stations.
  plotData = stats[which(as.character(stats$station) %in% stationNames), ]
  plotData$var = plotData[[stat]]

  # If banded stations, find mins and maxes and remove from stations
  # to create lines for.
  if(length(bandStations) > 0) {
    idx = which(plotData$station %in% bandStations)
    stopifnot(length(idx) > 0)

    bandData = plotData[idx,]
    bandData$val = bandData[[stat]]
    bandStats = ddply(bandData, .(POSIXtime), summarise,
                      min=min(val, na.rm=T), max=max(val, na.rm=T))
    bandStats$min[is.infinite(bandStats$min)] = NA
    bandStats$max[is.infinite(bandStats$max)] = NA
    bandStats$name = bandName
    bandRibbon = geom_ribbon(data=bandStats, aes(ymin=min,
                                                 ymax=max,
                                                 x=POSIXtime,
                                                 fill=name),
                             alpha=bandAlpha)
    bandMinLine = geom_line(data=bandStats, aes(x=POSIXtime, y=min),
                            lty=1, size=0.2, colour="black")
    bandMaxLine = geom_line(data=bandStats, aes(x=POSIXtime, y=max),
                            lty=1, size=0.2, colour="black")
    bandFill = scale_fill_manual(name="", values=bandColour)
    plotData = plotData[-idx,]
  }

  if(includePrecipCode) {
    codes = plotData$precipCode

    # Assign codes that will sit above the main plot.
    maxval = max(plotData$var, na.rm=T)
    inc = maxval / 10
    for(i in seq(1,length(precipCodes$code))) {
      code = precipCodes$code[i]
      axisCode = maxval + inc*(i+1)
      precipCodes$axisCode[i] = axisCode
      codes[which(codes == code)] = axisCode
    }

    plotData$plotCode = codes
    if(!bw) {
      codeLine = geom_point(aes(x=POSIXtime, y=plotCode, colour=station),
                            pch=20, size=1.5)
    } else {
      codeLine = geom_line(aes(x=POSIXtime, y=plotCode, linetype=station))
    }

    by = round(maxval / 3, 0)
    if(by == 0) {
      by = maxval / 3
    }

    codeAxis = scale_y_continuous(breaks=c(seq(0, maxval, by=by), precipCodes$axisCode),
                                  labels=c(seq(0, maxval, by=by), precipCodes$desc))
  }

  # Define whether to use black and white (different lines per station)
  # or colour (different colour per station, with solid lines.)
  if(bw) {
    line = geom_line(size=0.6, aes(linetype=station, y=var, group=station))
    scale = scale_linetype(name="Station")
  } else {
    line = geom_line(size=0.6, aes(colour=station, y=var, group=station))
    scale = scale_colour_brewer(type="all", palette=ColorPalette, name="Station")
  }

  timeString = paste(strftime(start, "%Y-%m-%d %H:%M:%S", tz="UTC"), "to",
                     strftime(end, "%Y-%m-%d %H:%M:%S", tz="UTC"))

  titleText=paste(statName, "by station during HYMEX SOP\n", timeString)
  if(!plotTitle) {
    titleText = ""
  }

  plot = ggplot(plotData, aes(x=POSIXtime))
  if(length(bandStations) > 0) {
    plot = plot + bandRibbon + bandMinLine + bandMaxLine + bandFill
  }

  plot = plot + line + scale +
    labs(title=titleText,
         x="Time",
         y=parse(text=paste(gsub(" ", "~", statName),
                            paste("group('[',", statUnits, ",']')",
                                  sep=""), sep="~"))) +
    theme_bw(textSize) +
    theme(panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.key=element_rect(colour="white"))

  if(includePrecipCode) {
    plot = plot + codeLine + codeAxis
  }

  return(plot)
}

analyseAllEvents = function(dsdData, events,
                            eventsToPlot=seq(1:length(events$start)),
                            savePlots=F, outdir=numeric(0), ...) {
  # Make plots for all the SOP events.
  #
  # Args:
  #   outdir: Output directory.
  #   dsdData: The parsivel dsd data.
  #   events: Event description (data frame with start, end, type).
  #   stats: Which statistic names to plot?
  #   titles: Titles for each statistic.
  #   units: Unit for each statistic.
  #   eventsToPlot: List of event numbers to plot.
  #   ...: Other options for plotting code.
  #
  # Returns:
  #   void.

  stopifnot(savePlots | length(outdir) ==  0)

  eventsRes = NULL

  for(e in eventsToPlot) {
    start = events$start[e]
    end = events$end[e]
    idx = which(dsdData$POSIXtime >= start & dsdData$POSIXtime <= end)

    # Conduct analysis of the event.
    eventAnalysis = analyseNetworkEvent(dsdData, start, end, ...)

    # Save all plots.
    for(plotname in names(eventAnalysis$plots)) {
      plot = eventAnalysis$plots[[plotname]]

      if(savePlots) {
        outname = paste("Event_",
                        strftime(start, "%Y%m%d_%H%M_", tz="UTC"),
                        strftime(end, "%Y%m%d_%H%M", tz="UTC"),
                        "_", plotname, ".png", sep="")
        savePlot(plot=plot, outDir=outdir, outname, width=10, height=5)
      }
    }

    # Pull out some interesting statistics, per station, save in text files.
    allStationStats = NULL
    for(s in seq(1, length(eventAnalysis$summaryStats[[1]]$station))) {
      station = as.character(eventAnalysis$summaryStats[[1]]$station[s])

      # Rain amount.
      amount = eventAnalysis$summaryStats$amount$sum[s]

      # Rain rate.
      R_mean = eventAnalysis$summaryStats$R$mean[s]
      R_sd = eventAnalysis$summaryStats$R$sd[s]
      R_max = eventAnalysis$summaryStats$R$max[s]

      # Drop concentration.
      Nt_mean = eventAnalysis$summaryStats$Nt$mean[s]

      # Mass weighted mean drop diameter.
      Dm_mean = eventAnalysis$summaryStats$Dm$mean[s]

      summaryStats = data.frame(station_name=station_name, amount=amount,
                                R_mean=R_mean, R_sd=R_sd, R_max=R_max,
                                Nt_mean=Nt_mean, Dm_mean=Dm_mean,
                                stringsAsFactors=F)
      allStationStats = rbind(allStationStats, summaryStats)
    }

    if(savePlots) {
      outname = paste(outdir, "/Event_Stats_",
                      strftime(start, "%Y%m%d_%H%M_", tz="UTC"),
                      strftime(end, "%Y%m%d_%H%M", tz="UTC"), ".dat", sep="")
      write.csv(summaryStats, file=outname, row.names=F)
    }

    eventsRes = c(eventsRes, list(list(eventStart=start,
                                       eventEnd=end,
                                       analysis=eventAnalysis,
                                       statsTable=allStationStats)))
  }

  return(eventsRes)
}

summaryByStation = function(data,
                                start = as.POSIXct("2012-09-01", tz="UTC"),
                                end = as.POSIXct("2012-12-01", tz="UTC")) {
  # Summary data collected by station over time.

  idx = which(data$POSIXtime >= start & data$POSIXtime < end)
  data = data[idx,]

  d = ddply(.data=data, .variables=c("station"), summarise,
            numRainySteps=length(which(amount > 0)),
            NAs=length(which(is.na(precipCode))),
            rainTime=(length(which(amount > 0))*30) / 3600,
            totalAmount=sum(amount, na.rm=T))
  names(d) = c("Station", "Rainy steps", "Missing steps", "Rain time [h]",
               "Amount [mm]")
  return(d)
}

arrangeTwoPlots = function(plot1, plot2, title=NULL, xLabel=NULL, yLabel=NULL,
                           textSize=12, plot1lab="(a)", plot2lab="(b)",
                           plotMargins=unit(c(rep(.1, 3), -.5), "lines"),
                           suppressPlotTitles=TRUE, includePlotLabels=TRUE,
                           stripYAxis=TRUE, saveToFile=FALSE, fileName="",
                           outHeight=500, outWidth=1000, legendPos="right",
                           plot1LegendPos="none", plot2LegendPos="none",
                           ...) {
  # Arrange and plot two ggplot objects side by side, using the same legend
  # for both. Titles will be removed from both plots.
  #
  # Args:
  #   plot1: The first plot.
  #   plot2: The second plot. The legend from this plot will be used.
  #   title: The title to use.
  #   xLabel: The x axis label (default: none).
  #   yLabel: The y axis label (default: none).
  #   textSize: Text size to use.
  #   plot1lab: Label for first plot.
  #   plot2lab: Label for second plot.
  #   plotMargins: Margins for each of the two plots.
  #   stripYaxis: Strip out the Y axis label from the plots? (Default: TRUE).
  #   suppressPlotTitles: Remove sub-plot titles? (Default: TRUE).
  #   includePlotLabels: Include plot labels? (Default: TRUE).
  #   save: Save to file? (Default: FALSE).
  #   fileName: File to save to.
  #   outHeight, outWidth: Output height and width in pixels
  #                        (default: 500, 1000).
  #   legendPos: Where to position the legend? (Default: "right").
  #   plot1LegendPos, plot2LegendPos: Where to position the individual plot
  #                                   legends (default: "none").
  #   ...: Extra arguments to grid.arrange().
  #
  # Returns: the arranged plot.

  tmp <- ggplot_gtable(ggplot_build(plot2))
  leg = which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  if(length(leg) > 0) {
    legend = tmp$grobs[[leg]]
  } else {
    legendPos = "none"
    legend = NULL
  }

  plot1 = plot1 +
    theme(legend.position=plot1LegendPos) +
    theme(plot.margin=plotMargins)

  plot2 = plot2 +
    theme(legend.position=plot2LegendPos) +
    theme(plot.margin=plotMargins)
    labs(title="")

  if(suppressPlotTitles) {
    plot1 = plot1 + labs(title="")
    plot2 = plot2 + labs(title="")
  }

  if(stripYAxis) {
    plot1 = plot1 + labs(y="")
    plot2 = plot2 + labs(y="")
  }

  gp=gpar(fontsize=textSize, cex=1)

  left=textGrob(yLabel, gp=gp, rot=90)
  sub=textGrob(xLabel, gp=gp)

  if(saveToFile) {
    png(filename=fileName, height=outHeight, width=outWidth)
  }

  titleGrob = textGrob(title,
                       gp=gpar(fontsize=textSize, cex=1.2, lineheight=2),
                       just=c("center","center"))

  if(includePlotLabels) {
      plots = arrangeGrob(textGrob(plot1lab, gp=gp), textGrob(plot2lab, gp=gp),
          plot1, plot2,
          nrow=2, ncol=2,
          heights=unit.c(unit(1, "lines"), unit(1,"npc") - unit(1,"lines")))
  } else {
    plots = arrangeGrob(plot1, plot2, nrow=1, ncol=2,
                        heights=unit.c(unit(1,"npc") - unit(1, "lines")))
  }

  ncols=2
  nrows=1

  if(legendPos == "right" | legendPos == "bottom") {
    panel1 = plots
    panel2 = legend
  } else if(legendPos == "left" | legendPos == "top") {
    panel1 = legend
    panel2 = plots
  } else if(legendPos == "none") {
    panel1 = plots
    panel2 = textGrob(NULL)
    legend$widths = unit(0, "npc")
  } else {
    stop("arrangeTwoPlots: Invalid legendPos argument.")
  }

  widths=unit.c(unit(1, "npc") - sum(legend$widths), sum(legend$widths))
  heights = unit.c(unit(1, "npc"), unit(1, "npc"))

  if(legendPos == "bottom" | legendPos == "top") {
    ncols = 1
    nrows = 2
    widths = unit.c(unit(1, "npc"), unit(1, "npc"))

    if(legendPos == "top") {
      heights = unit.c(sum(legend$heights),
                       unit(1, "npc") - sum(legend$heights))
    } else {
      heights = unit.c(unit(1, "npc") - sum(legend$heights),
                       sum(legend$heights))
    }
  }

  grid.arrange(panel1, panel2,
               main=titleGrob, nrow=nrows, ncol=ncols, left=left, sub=sub,
               widths=widths, heights=heights, ...)


  if(saveToFile) {
    dev.off()
  }
}

stackTwoPlots = function(plot1, plot2, title=NULL, xLabel=NULL, yLabel=NULL,
                         textSize=12, plot1lab="(a)", plot2lab="(b)",
                         plotMargins=unit(c(rep(.1, 3), -.1), "lines"),
                         suppressPlotTitles=TRUE, includePlotLabels=TRUE,
                         legendPos="right", plot1LegendPos="none",
                         plot2LegendPos="none", ...) {
  # Arrange and plot two ggplot objects one above the other, using the same
  # legend for both. Titles will be removed from both plots.
  #
  # Args:
  #   plot1: The first plot.
  #   plot2: The second plot. The legend from this plot will be used.
  #   title: The title to use.
  #   xLabel: The x axis label (default: none).
  #   yLabel: The y axis label (default: none).
  #   textSize: Text size to use.
  #   plot1lab: Label for first plot.
  #   plot2lab: Label for second plot.
  #   plotMargins: Margins for each of the two plots.
  #   suppressPlotTitles: Remove sub-plot titles? (Default: TRUE).
  #   includePlotLabels: Include plot labels? (Default: TRUE).
  #   legendPos: Where to position the legend? (Default: "right").
  #   plot1LegendPos, plot2LegendPos: Where to position the individual plot
  #                                   legends (default: "none").
  #   ...: Extra arguments to grid.arrange().
  #
  # Returns: the arranged plot.

  tmp <- ggplot_gtable(ggplot_build(plot2))
  leg = which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  if(length(leg) > 0) {
    legend = tmp$grobs[[leg]]
  } else {
    legendPos = "none"
    legend = NULL
  }

  plot1 = plot1 +
    theme(legend.position=plot1LegendPos) +
    theme(plot.margin=plotMargins)

  plot2 = plot2 +
    theme(legend.position=plot2LegendPos) +
    theme(plot.margin=plotMargins)
  labs(title="")

  if(suppressPlotTitles) {
    plot1 = plot1 + labs(title="")
    plot2 = plot2 + labs(title="")
  }

  gp=gpar(fontsize=textSize, cex=1)
  sub=textGrob(xLabel, gp=gp)

  titleGrob = textGrob(title,
                       gp=gpar(fontsize=textSize, cex=1.2, lineheight=2),
                       just=c("center","center"))

  if(includePlotLabels) {
    line1 = arrangeGrob(plot1, textGrob(plot1lab, gp=gp), nrow=2, ncol=1,
                        heights=unit.c(unit(1,"npc") - unit(1, "lines"),
                                       unit(1, "lines")))
    line2 = arrangeGrob(plot2, textGrob(plot2lab, gp=gp), nrow=2, ncol=1,
                        heights=unit.c(unit(1,"npc") - unit(1, "lines"),
                                       unit(1, "lines")))
    plots = arrangeGrob(line1, line2, nrow=2, ncol=1)
  } else {
    plots = arrangeGrob(plot1, plot2, nrow=2, ncol=1,
                        heights=unit.c(unit(1,"npc") - unit(1, "lines")))
  }

  ncols=2
  nrows=1

  if(legendPos == "right" | legendPos == "bottom") {
    panel1 = plots
    panel2 = legend
  } else if(legendPos == "left" | legendPos == "top") {
    panel1 = legend
    panel2 = plots
  } else if(legendPos == "none") {
    panel1 = plots
    panel2 = textGrob(NULL)
    legend$widths = unit(0, "npc")
  } else {
    stop("arrangeTwoPlots: Invalid legendPos argument.")
  }

  widths=unit.c(unit(1, "npc") - sum(legend$widths), sum(legend$widths))
  heights = unit.c(unit(1, "npc"), unit(1, "npc"))

  if(legendPos == "bottom" | legendPos == "top") {
    ncols = 2
    nrows = 1
    widths = unit.c(unit(1, "npc"), unit(1, "npc"))

    if(legendPos == "top") {
      heights = unit.c(sum(legend$heights),
                       unit(1, "npc") - sum(legend$heights))
    } else {
      heights = unit.c(unit(1, "npc") - sum(legend$heights),
                       sum(legend$heights))
    }
  }

  grid.arrange(panel1, panel2,
               main=titleGrob, nrow=nrows, ncol=ncols, sub=sub,
               widths=widths, heights=heights, ...)
}

arrangeFourPlots = function(plot1, plot2, plot3, plot4,
                            title=NULL, xLabel=NULL, yLabel=NULL,
                            textSize=12, plot1lab="(a)", plot2lab="(b)",
                            plot3lab="(c)", plot4lab="(d)",
                            plotMargins=unit(c(rep(.1, 3), -.5), "lines"),
                            suppressPlotTitles=TRUE, includePlotLabels=TRUE,
                            stripYAxis=TRUE, legendPos="right",
                            ...) {
  # Arrange and plot four ggplot objects side by side in two rows,
  # using the same legend for all. Titles will be removed.
  #
  # Args:
  #   plot1: The first plot.
  #   plot2: The second plot. The legend from this plot will be used.
  #   plot3: The third plot.
  #   plot4: The fourth plot.
  #   title: The title to use.
  #   xLabel: The x axis label (default: none).
  #   yLabel: The y axis label (default: none).
  #   textSize: Text size to use.
  #   plot1lab: Label for first plot.
  #   plot2lab: Label for second plot.
  #   plot3lab: Label for third plot.
  #   plot4lab: Label for fourth plot.
  #   plotMargins: Margins for each of the two plots.
  #   stripYaxis: Strip out the Y axis label from the plots? (Default: TRUE).
  #   suppressPlotTitles: Remove sub-plot titles? (Default: TRUE).
  #   includePlotLabels: Include plot labels? (Default: TRUE).
  #   legendPos: Where to position the legend? (Default: "right").
  #   ...: Extra arguments to grid.arrange().
  #
  # Returns: the arranged plot.

  tmp <- ggplot_gtable(ggplot_build(plot2))
  leg = which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  if(length(leg) > 0) {
    legend = tmp$grobs[[leg]]
  } else {
    legendPos = "none"
    legend = NULL
  }

  clearPlot = function(p) {
    return(p + theme(legend.position="none") +
             theme(plot.margin=plotMargins) + labs(title=""))
  }

  plot1 = clearPlot(plot1)
  plot2 = clearPlot(plot2)
  plot3 = clearPlot(plot3)
  plot4 = clearPlot(plot4)

  if(stripYAxis) {
    plot1 = plot1 + labs(y="")
    plot2 = plot2 + labs(y="")
    plot3 = plot3 + labs(y="")
    plot4 = plot4 + labs(y="")
  }

  gp=gpar(fontsize=textSize, cex=1)

  left=textGrob(yLabel, gp=gp, rot=90)
  sub=textGrob(xLabel, gp=gp)

  titleGrob = textGrob(title,
                       gp=gpar(fontsize=textSize, cex=1.2, lineheight=2),
                       just=c("center","center"))

  line1 = arrangeGrob(plot1, plot2,
                      textGrob(plot1lab, gp=gp),
                      textGrob(plot2lab, gp=gp),
                      nrow=2, ncol=2, left=left,
                      heights=unit.c(unit(1,"npc") - unit(1,"lines"),
                                     unit(1, "lines")))
  line2 = arrangeGrob(plot3, plot4,
                      textGrob(plot3lab, gp=gp),
                      textGrob(plot4lab, gp=gp),
                      nrow=2, ncol=2, left=left,
                      heights=unit.c(unit(1,"npc") - unit(1,"lines"),
                                     unit(1, "lines")))

  panel1 = arrangeGrob(line1, line2, nrow=2, ncol=1)
  panel2 = legend
  widths=unit.c(unit(1, "npc") - sum(legend$widths), sum(legend$widths))
  heights = unit.c(unit(1, "npc"), unit(1, "npc"))

  grid.arrange(panel1, panel2,
               main=titleGrob, nrow=1, ncol=2, sub=sub,
               widths=widths, heights=heights, ...)
}


eventDensity = function(data, start, end, variables, unit,
                        trans=log, timeRes="2 min", textSize=16,
                        title="All stations event densities",
                        subTitle="") {
  # Plot the normalised density of an events values over all stations
  # in the network.
  #
  # Args:
  #   data: The data.
  #   start, end: Start and end event times (POSIXt, UTC).
  #   variables: Variables to plot for.
  #   unit: Unit of the variables.
  #   trans: Transform the values? (Default: log).
  #   timeRes: Resample to what time resolution (Default: 2 mins).
  #   textSize: Text size for the plot (default: 16).
  #   subTitle: Sub title for the plot (default: none).
  #
  # Returns: A ggplot object.

  subset = data[which(data$POSIXtime >= start & data$POSIXtime <= end),]

  if(timeRes != "30 sec") {
    subset = resampleNetworkData(subset, timespan=timeRes)
  }

  toPlot = NULL

  for(variable in variables) {
    toPlot = cbind(toPlot, trans(subset[[variable]]))
  }

  func = function(x) {
    x[which(is.infinite(x))] = NA
    x = x - min(x, na.rm=T)
    x = x / max(x, na.rm=T)
  }

  # Normalise so values are between 0 and 1.
  toPlot = data.frame(apply(toPlot, 2, func))
  names(toPlot) = variables
  melted = melt(toPlot)

  title = paste(title, subTitle)

  plot =
    ggplot(melted) +
    geom_density(aes(x=value, group=variable, fill=variable), alpha=0.5) +
    theme_bw(textSize) +
    labs(title=title, x="Normalised value", y="Density") +
    scale_fill_discrete(name="Variable")

  return(plot)
}

setPlotsToEqualLimits = function(plotOne, plotTwo, variable, unit, varName=variable) {
  # Take two plots and give their colour scales the same limits.
  #
  # Args:
  #  plotOne: The first ggplot2 object.
  #  plotTwo: The second plot.
  #  variable: The variable to look at.
  #  unitStrings:

  lims = range(c(plotOne$data[[variable]], plotTwo$data[[variable]]),
               na.rm=TRUE)

  statName = parse(text=paste(varName, "~group('[',",
                              unit, ",']')",
                              sep=""))

  colours = c(col.Rbar)
  plotOne = plotOne +
    scale_fill_gradientn(limits=lims, colours=colours,
                         na.value="grey", name=statName) +
    scale_colour_gradientn(limits=lims, colours=colours,
                           na.value="grey", name=statName)

  plotTwo = plotTwo +
    scale_fill_gradientn(limits=lims, colours=colours,
                         na.value="grey", name=statName) +
    scale_colour_gradientn(limits=lims, colours=colours,
                           na.value="grey", name=statName)

  return(list(plotOne, plotTwo))
}

joinParsivelData = function(baseDir, pars2012v1File, pars2012v2File,
    pars2013v1File, pars2013v2File, timeRes,
    events=NULL,
    stations, minR=0.1, maxSolidPrecip=0,
    dsdCols=paste("class", seq(1,32), sep=""),
    radar=TRUE, removeColloc=TRUE,
    ...) {
    ## Helper function: read in Parsivel v1 and v2 data from 2012 and 2013,
    ## return only liquid rain.
    ## ... -> addRainStats()

  ## Read in all available Parsivel data.
  pars2012_v1 = data.table(loadFile(baseDir, pars2012v1File))
  pars2013_v1 = data.table(loadFile(baseDir, pars2013v1File))
  pars_v1 = rbind(pars2012_v1, pars2013_v1)

  pars2012_v2 = data.table(loadFile(baseDir, pars2012v2File))
  pars2013_v2 = data.table(loadFile(baseDir, pars2013v2File))
  pars_v2 = rbind(pars2012_v2, pars2013_v2)

  ## Avoid name clashes with the HYMEX V2 data.
  pars_v2 = pars_v2[station == "Pradel Grainage v2", station := "Pradel-Grainage-v2"]

  ## Don't keep the first or second class in Parsivel v2 data.
  pars_v2 = pars_v2[, class1 := 0]
  pars_v2 = pars_v2[, class2 := 0]

  ## If at 60 seconds, add in containedNonZeroStatus and solidPrecipProp
  if(timeRes == 60) {
    pars_v2[, solidPrecipProp := as.integer((precipCode == 1))]
    pars_v2[, containedSusp := (precipCode == -2)]
    pars_v2[, containedNonZeroStatus := (parsivelStatus != 0)]
    pars_v2[, precipCode := NULL]
    pars_v2[, parsivelStatus := NULL]
  }

  remCols = c("temp", "wDensity", "alt", "lat", "moment_3", "moment_4")
  remCols_v1 = remCols[which(remCols %in% names(pars_v1))]
  remCols_v2 = remCols[which(remCols %in% names(pars_v2))]
  if(length(remCols_v1) > 0)
      pars_v1[, (remCols_v1) := NULL]
  if(length(remCols_v2) > 0)
      pars_v2[, (remCols_v2) := NULL]

  ## Join v1 and v2 datasets.
  allPars = bindAll(pars_v1, pars_v2)

  ## Remove collocated stations, except Pradel 2 which is used for nugget.
  if(removeColloc) {
      allPars = allPars[station != "Villeneuve-de-Berg 2"]
      allPars = allPars[station != "Villeneuve-de-Berg 3"]
      allPars = allPars[station != "Pradel-Grainage-v2"]
  }

  ## Keep all rain rate records.
  rainrates = copy(allPars[, list(station, POSIXtime, R)])

  ## Subset to the chosen events.
  if(!is.null(events))
    allPars = subsetToEvents(allPars, events)

  ## Subset to liquid rain.
  allPars = liquidRain(allPars, maxSolidProp=maxSolidPrecip, minR=minR)

  ## Add in bulk variables.
  allPars = addRainStats(allPars, timestepSeconds=timeRes,
      radar=radar, stations=stations, ...)
  allPars = data.table(allPars)

  ## Make a copy that includes only unique stations.
  uniquePars = copy(allPars)[!(station %in% c("Pradel 2", "Villeneuve-de-Berg 2",
      "Villeneuve-de-Berg 3", "Pradel-Grainage-v2"))]

  ## Define classes to work on.
  dropClassNums = uniquePars[, as.numeric(which(lapply(.SD, sum) > 0)), .SDcols=dsdCols]
  dropCols = paste("class", dropClassNums, sep="")
  spectra = copy(allPars[, c("POSIXtime", "station", dropCols), with=FALSE])

  return(list(spectra=spectra, allPars=allPars, uniquePars=uniquePars,
              dropCols=dropCols))
}

## Subset DSDs to liquid precipitation only.
liquidRain = function(d, maxSolidProp=0, minR=0.1, minParsivelR=0.025) {
    ## Select only liquid rain to work on.
    ## Notes:
    ##  - DSDs where solid precip was predicted are already set to NA and ignored.
    ##  - DSDs where the Parsivel recorded zero but drops were counted
    ##    are already set to zeros.

    ## Include zeros if required.
    if(minR < 0)
        minParsivelR = minR

    res = d[!containedNonZeroStatus &      ## Filter out Parsivel errors.
        R > minR &                         ## Filter out R too low.
        solidPrecipProp <= maxSolidProp &  ## Filter out steps with too many solid detections.
        parsivelR > minParsivelR]          ## Filter when parsivel R was very close to zero.

  return(res)
}

loadFile = function(baseDir, file) {
  name = load(paste(baseDir, file, sep="/"))
  return(get(name))
}

## rbind a set of n data.frames or data.tables.
bindAll = function(a, ...) {
  if(length(list(...)) == 0)
    return(a)
  return(rbind(a, bindAll(...), use.names=TRUE))
}

combinedSOPstations = function() {
  ## Stations definitions.
  stations = rbind(data.frame(stationsDefinition_2013(), gen="p1"),
                   data.frame(grenobleParsivelStations(), gen="p2"))
  stations = data.table(stations, key="name")
  stations[name == "Pradel-Vignes", gen := "p1"]
  stations[name == "Mont-Redon", gen := "p1"]
  stations = unique(stations)
  stations[name == "Pradel Grainage v2", name := "Pradel-Grainage-v2"]
  return(stations)
}

bestBoundingBox = function(l, stations, metresCRS) {
  width = l
  height = l

  stationsGeo = stations[c(-8, -10, -15, -16),]
  stationsGeo$lat = NULL
  stationsGeo$lon = NULL
  stationsGeo$station = stationsGeo$name
  stationsGeo = addStationLocations(stationsGeo, stations=stations)
  stationsGeo = spTransform(stationsGeo, metresCRS)

  ## The number of stations within a bounding box.
  stationsInBox = function(x, y, w, h) {
    return(length(which(coordinates(stationsGeo)[,1] >= x &
                          coordinates(stationsGeo)[,1] <= x + w &
                          coordinates(stationsGeo)[,2] >= y &
                          coordinates(stationsGeo)[,2] <= y + h)))
  }

  minX = min(coordinates(stationsGeo)[,1]-1000)
  maxX = max(coordinates(stationsGeo)[,1]+1000)
  minY = min(coordinates(stationsGeo)[,2]-1000)
  maxY = max(coordinates(stationsGeo)[,2]+1000)

  res = data.table()
  for(x in seq(minX, maxX, by=100)) {
    for(y in seq(minY, maxY, by=100)) {
      n = stationsInBox(x, y, width, height)
      if(n > 0)
        res = rbind(res, data.table(x=x, y=y, n=n))
    }
  }

  ## Ensure that we only have one best area: 100 is the resolution of the dsd grid.
  stopifnot(res[n == res[, max(n)], max(diff(x))] == 100)
  stopifnot(res[n == res[, max(n)], max(diff(y))] == 100)

  ## Take the middle values for x and y.
  bestX = res[n == res[, max(n)], sort(unique(x))[as.integer(length(unique(x))/2)]]
  bestY = res[n == res[, max(n)], sort(unique(y))[as.integer(length(unique(y))/2)]]

  ## Find the most central Parsivel-1 station.
  centreX = bestX + width/2
  centreY = bestY + height/2
  centrePoint = data.frame(x=centreX, y=centreY)
  coordinates(centrePoint) = ~x+y
  proj4string(centrePoint) = metresCRS
  s = stationsGeo[which(stationsGeo$gen == "p1"),]
  closestStation = s$name[which.min(spDists(centrePoint, s))]

  xPoints = c(bestX, bestX + width, bestX + width, bestX, bestX) / 1000
  yPoints = c(bestY, bestY, bestY + height, bestY + height, bestY) / 1000
  box = data.frame(x=xPoints, y=yPoints)

  return(list(x=bestX, y=bestY, stats=stationsGeo, box=box,
              closestStation=closestStation))
}

makeGrid = function(bbox, l, res=100,
                    metresCRS=CRS(paste("+proj=utm +zone=31 +ellps=WGS84",
                                        "+datum=WGS84 +units=m +no_defs"))) {
  # Coordinates are assumed to be in metresCRS.
  x = seq(bbox$x, bbox$x + l, by=res)
  y = seq(bbox$y, bbox$y + l, by=res)
  grid = expand.grid(x, y)
  coordinates(grid) = ~Var1+Var2
  proj4string(grid) = metresCRS
  return(grid)
}

makeBbox = function(x, y, l) {
    box = data.frame(x=c(x, x+l, x+l, x, x),
        y=c(y, y, y+l, y+l, y))
    return(box)
}

smallBbox = function() {
    stop("Shoudl use smallBbox2.8")
    # 2x2 bounding box containing Pradels, Pradel-Vignes, Pradel Grainage.
    # In UTM zone 31 metres.
    res = list(x=617824.8, y=4936450, l=2000)
    res$box = makeBbox(res$x/1000, res$y/1000, res$l/1000)
    return(res)
}

smallBbox2.8 = function() {
  ## 2x2 bounding box containing Pradels, Pradel-Vignes, Pradel Grainage.
  ## In UTM zone 31 metres. Lines up with large bounding box so can
  ## just be subset from large data.

  res = list(x=616724.8, y=4935750, l=2800)
  res$box = makeBbox(res$x/1000, res$y/1000, res$l/1000)
  return(res)
}

largeBbox = function() {
    # 5x5 bounding box in UTM zone 31 metres.
    res = list(x=614524.8, y=4933550, l=5000)
    res$box = makeBbox(res$x/1000, res$y/1000, res$l/1000)
    return(res)
}
